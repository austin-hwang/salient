'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDimArraysForRoot = exports.getDimArraysForLayer = exports.extractDimArray = undefined;

var _isUndefined2 = require('lodash/isUndefined');

var _isUndefined3 = _interopRequireDefault(_isUndefined2);

var _mergeWith2 = require('lodash/mergeWith');

var _mergeWith3 = _interopRequireDefault(_mergeWith2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _reduce2 = require('lodash/reduce');

var _reduce3 = _interopRequireDefault(_reduce2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _flow2 = require('lodash/flow');

var _flow3 = _interopRequireDefault(_flow2);

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

var _head2 = require('lodash/head');

var _head3 = _interopRequireDefault(_head2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // Copyright 2017 Kensho Technologies, Inc.

var _compactData = require('../../chartCore/compactData');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var checkUndefinedAccessor = function checkUndefinedAccessor(value) {
  return !(0, _isString3.default)(value) || value === '';
};
/*
quick check if data is array of arrays
*/
var tidyFlatten = function tidyFlatten(data) {
  if ((0, _isArray3.default)((0, _head3.default)(data))) return (0, _flatten3.default)(data);
  return data;
};
/*
for a layer.data, extract the dim array using an accessor
*/
var extractDimArray = exports.extractDimArray = function extractDimArray(data, accessor) {
  return (0, _flow3.default)(tidyFlatten, function (_data) {
    return (0, _map3.default)(_data, accessor);
  }, _compactData.compactData)(data
  /*
  according to the local defined accessors, extract and compact the dimArrays
  */
  );
};var getDimArraysForLayer = exports.getDimArraysForLayer = function getDimArraysForLayer(layer) {
  if (layer.skipExtractArrays === true) return {};
  var localAccessors = layer.localAccessors;

  return (0, _reduce3.default)(localAccessors, function (acc, accessor, key) {
    if (checkUndefinedAccessor(accessor)) return acc;
    var dimArray = extractDimArray(layer.data, accessor);
    if ((0, _isEmpty3.default)(dimArray)) return acc;
    return _extends({}, acc, _defineProperty({}, key, dimArray));
  }, {});
};
/*
Get dimension array from each layer, and merge the arrays with the same key.
*/
var getDimArraysForRoot = exports.getDimArraysForRoot = function getDimArraysForRoot(props) {
  var layersArrays = (0, _map3.default)(props.layers, getDimArraysForLayer);
  var dimArrays = _mergeWith3.default.apply(undefined, [{}].concat(_toConsumableArray(layersArrays), [function (a, b) {
    if ((0, _isUndefined3.default)(a)) return b;
    if ((0, _isUndefined3.default)(b)) return a;
    return a.concat(b);
  }]));
  return dimArrays;
};