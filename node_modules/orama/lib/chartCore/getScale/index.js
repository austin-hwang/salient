'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getScale = exports.getDefaultScale = exports.getAxisScale = exports.getOrdinalInvert = undefined;

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _findIndex2 = require('lodash/findIndex');

var _findIndex3 = _interopRequireDefault(_findIndex2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _d3Scale = require('d3-scale');

var d3Scale = _interopRequireWildcard(_d3Scale);

var _defaults = require('../../chartCore/defaults');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
`getScale` returns the scale for a key according to configurations on props object.

@calling logic
getScale{
  getAxisScale{
    d3Scale()
  }
  getDefaultScale{
    d3Scale()
  }
}

@example
getScale({xType, xDomain, xRange, xTickCount}, 'x')
returns {
  ...props,
  xScale,
}
*/

/*
get a scale with logic for the x and y axis, if the domain starts and finishes on the same number returns the mid range value.
*/
// Copyright 2017 Kensho Technologies, Inc.

var getBaseScales = function getBaseScales(type, domain, range, nice, tickCount) {
  if (type === 'time') {
    var timeScale = d3Scale.scaleUtc().domain(domain).range(range);
    if (nice) timeScale.nice(tickCount);
    return timeScale;
  }
  if (type === 'log') {
    var logScale = d3Scale.scaleLog().domain(domain).range(range);
    if (nice) logScale.nice(tickCount);
    return logScale;
  }
  var linearScale = d3Scale.scaleLinear().domain(domain).range(range);
  if (nice) linearScale.nice(tickCount);
  return linearScale;
};

var getOrdinalInvert = exports.getOrdinalInvert = function getOrdinalInvert(scale) {
  var mapArray = (0, _map3.default)(scale.domain(), function (raw) {
    return {
      raw: raw, mapped: scale(raw)
    };
  });
  return function (input) {
    var hoverIndex = (0, _findIndex3.default)(mapArray, function (d) {
      return (0, _get3.default)(d, 'mapped') > input;
    });
    if (hoverIndex === 0) {
      var _hoverData = mapArray[hoverIndex];
      return _hoverData.raw;
    }
    if (hoverIndex === -1) {
      var _hoverData2 = (0, _last3.default)(mapArray);
      return _hoverData2.raw;
    }
    var px = (0, _get3.default)(mapArray[hoverIndex], 'mapped');
    var x = (0, _get3.default)(mapArray[hoverIndex - 1], 'mapped');
    if (input - px < x - input) {
      var _hoverData3 = mapArray[hoverIndex - 1];
      return _hoverData3.raw;
    }
    var hoverData = mapArray[hoverIndex];
    return hoverData.raw;
  };
};

var getAxisScale = exports.getAxisScale = function getAxisScale(props, key) {
  var _props$ = props[key + 'Type'],
      type = _props$ === undefined ? _defaults.TYPE : _props$,
      _props$2 = props[key + 'Domain'],
      domain = _props$2 === undefined ? _defaults.DOMAIN : _props$2,
      _props$3 = props[key + 'Range'],
      range = _props$3 === undefined ? _defaults.RANGE : _props$3,
      _props$4 = props[key + 'TickCount'],
      tickCount = _props$4 === undefined ? _defaults.TICK_COUNT : _props$4,
      _props$5 = props[key + 'Nice'],
      nice = _props$5 === undefined ? _defaults.NICE : _props$5;

  switch (type) {
    case 'ordinal':
      var scaleOrdinal = d3Scale.scalePoint().domain(domain).range(range).padding(0.5);
      scaleOrdinal.invert = getOrdinalInvert(scaleOrdinal);
      return scaleOrdinal;
    default:
      if (domain[0] === domain[1]) {
        var midRange = range[0] + (range[1] - range[0]) / 2;
        var linearScaleFlatDomain = function linearScaleFlatDomain() {
          return midRange;
        };
        linearScaleFlatDomain.tickFormat = function () {
          return function (d) {
            return d;
          };
        };
        linearScaleFlatDomain.ticks = function () {
          return [domain[0]];
        };
        return linearScaleFlatDomain;
      }
      return getBaseScales(type, domain, range, nice, tickCount);
  }
};
var getDefaultScale = exports.getDefaultScale = function getDefaultScale(props, key) {
  var _props$6 = props[key + 'Type'],
      type = _props$6 === undefined ? _defaults.TYPE : _props$6,
      _props$7 = props[key + 'Domain'],
      domain = _props$7 === undefined ? _defaults.DOMAIN : _props$7,
      _props$8 = props[key + 'Range'],
      range = _props$8 === undefined ? _defaults.RANGE : _props$8,
      _props$9 = props[key + 'TickCount'],
      tickCount = _props$9 === undefined ? _defaults.TICK_COUNT : _props$9,
      _props$10 = props[key + 'Nice'],
      nice = _props$10 === undefined ? _defaults.NICE : _props$10;

  switch (type) {
    case 'ordinal':
      var scaleOrdinal = d3Scale.scaleOrdinal().domain(domain).range(range);
      return scaleOrdinal;
    default:
      return getBaseScales(type, domain, range, nice, tickCount);
  }
};
/*
Main exported function, used outside of the module on the Chart props transform flow.
*/
var getScale = exports.getScale = function getScale(props, key) {
  switch (key) {
    case 'x':
    case 'y':
      return getAxisScale(props, key);
    default:
      return getDefaultScale(props, key);
  }
};