'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rerunCheckGetDimArrays = exports.rerunCheckGetRenderLayers = exports.rerunCheckGetScales = exports.rerunCheckGetTickCounts = exports.rerunCheckGetRanges = exports.rerunCheckGetPlotRect = exports.rerunCheckGetDomains = exports.rerunCheckGetTypes = exports.getRerunCheckForNames = undefined;

var _some2 = require('lodash/some');

var _some3 = _interopRequireDefault(_some2);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright 2017 Kensho Technologies, Inc.

function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }
  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  // Test for A's keys different from B.
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (var i = 0; i < keysA.length; i++) {
    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }
  return true;
}

var getRerunCheckForNames = exports.getRerunCheckForNames = function getRerunCheckForNames(keyNames, rootNames) {
  return function (props, prevProps) {
    var checkRootNames = (0, _some3.default)(rootNames, function (name) {
      return props['' + name] !== prevProps['' + name];
    });
    if (checkRootNames) return true;
    if (!keyNames) return false;
    return (0, _some3.default)(props.groupedKeys, function (key) {
      return (0, _some3.default)(keyNames, function (name) {
        return props['' + key + name] !== prevProps['' + key + name];
      });
    });
  };
};

var rerunCheckGetTypes = exports.rerunCheckGetTypes = getRerunCheckForNames(['Type', 'Array']);
var rerunCheckGetDomains = exports.rerunCheckGetDomains = getRerunCheckForNames(['Domain', 'Array', 'Type', 'ZeroBased']);
var rerunCheckGetPlotRect = exports.rerunCheckGetPlotRect = getRerunCheckForNames(['Array', 'ShowTicks', 'ShowLabel'], ['width', 'height', 'margin', 'proportion']);
var rerunCheckGetRanges = exports.rerunCheckGetRanges = getRerunCheckForNames(['Range', 'Type', 'Array'], ['plotRect']);
var rerunCheckGetTickCounts = exports.rerunCheckGetTickCounts = getRerunCheckForNames(['TickCount', 'Range', 'TickSpace']);
var rerunCheckGetScales = exports.rerunCheckGetScales = getRerunCheckForNames(['Type', 'Domain', 'Range', 'TickCount', 'Nice']);

var rerunCheckGetRenderLayers = exports.rerunCheckGetRenderLayers = getRerunCheckForNames(['Array', 'Domain', 'Range', 'Scale'], ['data']

// check change for root and layers on: accessors, data, and skipExtractArrays
);var rerunCheckGetDimArrays = exports.rerunCheckGetDimArrays = function rerunCheckGetDimArrays(props, prevProps) {
  // now there are layers
  if (!prevProps.layers && props.layers) return true;
  // for each layer
  var layerCheck = (0, _some3.default)(props.layers, function (layer, i) {
    // should skip
    if (layer.skipExtractArrays) return false;
    var prevLayer = prevProps.layers[i];
    // new layer
    if (!prevLayer) return true;
    // new data on the layer
    if (layer.data !== prevLayer.data) return true;
    // new accessors on the layer
    return !shallowEqual(layer.localAccessors, prevLayer.localAccessors);
  });
  if (layerCheck) return true;
  return false;
};