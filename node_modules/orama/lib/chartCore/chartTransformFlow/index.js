'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.chartTransformFlow = exports.removeDimArrays = undefined;

var _slice2 = require('lodash/slice');

var _slice3 = _interopRequireDefault(_slice2);

var _reduce2 = require('lodash/reduce');

var _reduce3 = _interopRequireDefault(_reduce2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright 2017 Kensho Technologies, Inc.

var PROPS_TO_OMIT = ['memoizers', 'onUpdate', 'onState', 'layerProps', 'rootProps'];

/*
Start with the input props, send then to the first transform, merge the returned new props back to the props. Do again with the next transform.

const rootProps = chartTransformFlow(
  props,
  t1,
  t2,
  t3
)
*/

var removeDimArrays = exports.removeDimArrays = function removeDimArrays(props) {
  var names = (0, _map3.default)(props.groupedKeys, function (key) {
    return key + 'Array';
  });
  return (0, _omit3.default)(props, names);
};

var transformFlow = function transformFlow(arg) {
  return (0, _reduce3.default)((0, _slice3.default)(arg, 1), function (acc, d) {
    return _extends({}, acc, d(acc));
  }, (0, _omit3.default)(arg[0], PROPS_TO_OMIT));
};

var chartTransformFlow = exports.chartTransformFlow = function chartTransformFlow() {
  for (var _len = arguments.length, arg = Array(_len), _key = 0; _key < _len; _key++) {
    arg[_key] = arguments[_key];
  }

  return removeDimArrays(transformFlow(arg));
};