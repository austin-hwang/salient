'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPlotRect = exports.getMaxTextWidth = exports.getTextWidth = undefined;

var _sum2 = require('lodash/sum');

var _sum3 = _interopRequireDefault(_sum2);

var _includes2 = require('lodash/includes');

var _includes3 = _interopRequireDefault(_includes2);

var _isUndefined2 = require('lodash/isUndefined');

var _isUndefined3 = _interopRequireDefault(_isUndefined2);

var _max2 = require('lodash/max');

var _max3 = _interopRequireDefault(_max2);

var _reduce2 = require('lodash/reduce');

var _reduce3 = _interopRequireDefault(_reduce2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // Copyright 2017 Kensho Technologies, Inc.

var _canvasUtils = require('../../utils/canvasUtils');

var _getForKey = require('../../chartCore/getForKey');

var _defaults = require('../defaults');

var _rectUtils = require('../../utils/rectUtils');

var rectUtils = _interopRequireWildcard(_rectUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
`addPlotRect` calculate and assign the plotRect to a new props.
props.size gets insetted by props.margin to generate the plotRect.
when props.margin is not defined (or only partially defined), addPlotRect smartly calculates the margins, by taking into consideration axis label, ticks width and backgroundOffset.

@calling logic
addPlotRect{
  getTopMargin{}
  getBottomMargin{}
  getLeftMargin{
    getMaxTextWidth{}
  }
  getRightMargin{
    getTextWidth{}
  }
}

@example
addPlotRect({size})
returns {size, plotRect}
*/

var getTextWidth = exports.getTextWidth = function getTextWidth(theme, string) {
  var ctx = (0, _canvasUtils.getCachedContext)();
  ctx.save();
  ctx.font = theme.axisTickFontSize + 'px ' + theme.fontFamilyMono;
  var width = ctx.measureText(string).width;
  ctx.restore();
  return width;
};
/*
get the maximum width of the strings contained in `ticks`.
Uses a offscreen canvas for doing the measure and takes into consideration the theme object.
*/
var getMaxTextWidth = exports.getMaxTextWidth = function getMaxTextWidth(theme, ticks) {
  var ctx = (0, _canvasUtils.getCachedContext)();
  ctx.save();
  ctx.font = theme.axisTickFontSize + 'px ' + theme.fontFamilyMono;
  var maxWidth = (0, _reduce3.default)(ticks, function (acc, d) {
    return (0, _max3.default)([acc, ctx.measureText(d.text).width]);
  }, 0);
  ctx.restore();
  return maxWidth;
};
var getTopMargin = function getTopMargin(props) {
  var _props$backgroundOffs = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs === undefined ? _defaults.BACKGROUND_OFFSET : _props$backgroundOffs,
      _props$margin = props.margin,
      margin = _props$margin === undefined ? {} : _props$margin,
      theme = props.theme,
      y = props.y,
      _props$yShowTicks = props.yShowTicks,
      yShowTicks = _props$yShowTicks === undefined ? _defaults.SHOW_TICKS : _props$yShowTicks;

  if (!(0, _isUndefined3.default)(margin.top)) return margin.top + backgroundOffset;
  if (yShowTicks === false || !y) return backgroundOffset;
  return (0, _max3.default)([backgroundOffset, theme.axisTickFontSize / 2]);
};
var getBottomMargin = function getBottomMargin(props) {
  var theme = props.theme;
  var _props$backgroundOffs2 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs2 === undefined ? _defaults.BACKGROUND_OFFSET : _props$backgroundOffs2,
      groupedKeys = props.groupedKeys,
      _props$margin2 = props.margin,
      margin = _props$margin2 === undefined ? {} : _props$margin2,
      _props$xShowTicks = props.xShowTicks,
      xShowTicks = _props$xShowTicks === undefined ? _defaults.SHOW_TICKS : _props$xShowTicks,
      _props$xShowLabel = props.xShowLabel,
      xShowLabel = _props$xShowLabel === undefined ? _defaults.SHOW_LABELS : _props$xShowLabel,
      _props$xTickOffset = props.xTickOffset,
      xTickOffset = _props$xTickOffset === undefined ? (0, _defaults.AXIS_TICK_OFFSET)(theme) : _props$xTickOffset,
      _props$xLabelOffset = props.xLabelOffset,
      xLabelOffset = _props$xLabelOffset === undefined ? (0, _defaults.AXIS_LABEL_OFFSET)(theme) : _props$xLabelOffset;

  if (!(0, _isUndefined3.default)(margin.bottom)) return margin.bottom + backgroundOffset;
  if (!(0, _includes3.default)(groupedKeys, 'x')) return backgroundOffset;
  return (0, _sum3.default)([backgroundOffset, xShowTicks ? xTickOffset + theme.axisTickFontSize : 0, xShowLabel ? xLabelOffset + theme.axisLabelFontSize : 0]);
};
var getLeftMargin = function getLeftMargin(props) {
  var theme = props.theme;
  var _props$backgroundOffs3 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs3 === undefined ? _defaults.BACKGROUND_OFFSET : _props$backgroundOffs3,
      groupedKeys = props.groupedKeys,
      _props$margin3 = props.margin,
      margin = _props$margin3 === undefined ? {} : _props$margin3,
      _props$yShowTicks2 = props.yShowTicks,
      yShowTicks = _props$yShowTicks2 === undefined ? _defaults.SHOW_TICKS : _props$yShowTicks2,
      _props$yShowLabel = props.yShowLabel,
      yShowLabel = _props$yShowLabel === undefined ? _defaults.SHOW_LABELS : _props$yShowLabel,
      _props$yTickOffset = props.yTickOffset,
      yTickOffset = _props$yTickOffset === undefined ? (0, _defaults.AXIS_TICK_OFFSET)(theme) : _props$yTickOffset,
      _props$yLabelOffset = props.yLabelOffset,
      yLabelOffset = _props$yLabelOffset === undefined ? (0, _defaults.AXIS_LABEL_OFFSET)(theme) : _props$yLabelOffset;

  if (!(0, _isUndefined3.default)(margin.left)) return margin.left + backgroundOffset;
  if (!(0, _includes3.default)(groupedKeys, 'y')) return backgroundOffset;
  if (!yShowTicks) {
    return (0, _sum3.default)([backgroundOffset, yShowLabel ? yLabelOffset + theme.axisLabelFontSize : 0]);
  }
  var yRange = props.yRange || (0, _getForKey.getRange)(props, 'y');
  var yTickCount = props.yTickCount || (0, _getForKey.getTickCount)(_extends({}, props, { yRange: yRange }), 'y');
  var yTicks = props.yTicks || (0, _getForKey.getTicks)(_extends({}, props, { yTickCount: yTickCount }), 'y');
  var yMaxTickWidth = getMaxTextWidth(theme, yTicks);
  return (0, _sum3.default)([backgroundOffset, yMaxTickWidth, yShowTicks ? yTickOffset : 0, yShowLabel ? yLabelOffset + 5 + theme.axisLabelFontSize : 0]);
};
var getRightMargin = function getRightMargin(props) {
  var _props$backgroundOffs4 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs4 === undefined ? _defaults.BACKGROUND_OFFSET : _props$backgroundOffs4,
      _props$margin4 = props.margin,
      margin = _props$margin4 === undefined ? {} : _props$margin4,
      x = props.x,
      _props$xShowTicks2 = props.xShowTicks,
      xShowTicks = _props$xShowTicks2 === undefined ? _defaults.SHOW_TICKS : _props$xShowTicks2;

  if (!(0, _isUndefined3.default)(margin.right)) return margin.right + backgroundOffset;
  if (!x || !xShowTicks) return backgroundOffset;
  return backgroundOffset;
};

var getPlotRect = exports.getPlotRect = function getPlotRect(props) {
  if (props.plotRect) return props;
  var _props$backgroundOffs5 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs5 === undefined ? _defaults.BACKGROUND_OFFSET : _props$backgroundOffs5,
      groupedKeys = props.groupedKeys,
      width = props.width,
      _props$height = props.height,
      height = _props$height === undefined ? props.width * props.proportion : _props$height;


  var top = getTopMargin(props);
  var bottom = getBottomMargin(props);
  var partialPlotRect = rectUtils.marginInset({ bottom: bottom, top: top }, { width: width, height: height });
  var left = getLeftMargin(_extends({}, props, { plotRect: partialPlotRect }));
  partialPlotRect = rectUtils.marginInset({ bottom: bottom, top: top, left: left }, { width: width, height: height });
  var right = getRightMargin(_extends({}, props, { plotRect: partialPlotRect }));

  var margin = {
    left: left,
    bottom: bottom,
    top: top,
    right: right
  };
  var newWidth = width;
  var newHeight = height;
  var plotRect = rectUtils.marginInset(margin, { width: width, height: height });
  if (!(0, _includes3.default)(groupedKeys, 'x')) {
    newWidth -= plotRect.width;
    plotRect.width = 0;
  }
  if (!(0, _includes3.default)(groupedKeys, 'y')) {
    newHeight -= plotRect.height;
    plotRect.height = 0;
  }
  if (plotRect.height < 0) {
    plotRect.height = 0;
    newHeight = top + bottom;
  }
  if (plotRect.width < 0) {
    plotRect.width = 0;
    newWidth = left + right;
  }
  return {
    backgroundOffset: backgroundOffset,
    margin: margin,
    plotRect: plotRect,
    width: newWidth,
    height: newHeight
  };
};