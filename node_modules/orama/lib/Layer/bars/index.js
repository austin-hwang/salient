'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bars = exports.getBarsRenderData = undefined;

var _isNumber2 = require('lodash/isNumber');

var _isNumber3 = _interopRequireDefault(_isNumber2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // Copyright 2017 Kensho Technologies, Inc.

var _path2DUtils = require('../../utils/path2DUtils');

var _getPlotValues = require('../../Layer/getPlotValues');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GUTTER = 1;

var getBarsRenderData = exports.getBarsRenderData = function getBarsRenderData(props, datum, idx) {
  var _props$barsGutter = props.barsGutter,
      gutter = _props$barsGutter === undefined ? GUTTER : _props$barsGutter;

  var path2D = (0, _path2DUtils.getPath2D)();
  var values = (0, _getPlotValues.getPlotValues)(props, datum, idx, {
    x: props.plotRect.x,
    y: props.plotRect.y
  }

  // when `x1` or `y1` is present, this means the bars are been positioned on a linear scale, and their position has been previously calculated
  );if ((0, _isNumber3.default)(values.x1) && (0, _isNumber3.default)(values.x2)) {
    var y0 = props.yScale(0);
    path2D.rect(values.x1 + gutter, y0, values.x2 - values.x1 - gutter * 2, values.y - y0);
  } else if ((0, _isNumber3.default)(values.y1) && (0, _isNumber3.default)(values.y2)) {
    var x0 = props.xScale(0);
    path2D.rect(x0, values.y1 - gutter, values.x - x0, values.y2 - values.y1 + gutter * 2
    // one of the axis is ordinal, so the width of the bar is calculated by the number of itens on the domain
    );
  } else if (props.yType === 'ordinal' || props.xType === 'ordinal') {
    if (props.xType === 'ordinal' || props.barOrientation === 'vertical') {
      var width = props.plotRect.width / props.xDomain.length;
      var _y = props.yScale(0);
      path2D.rect(values.x - width / 2 + gutter, _y, width - gutter * 2, values.y - _y);
    } else {
      var height = props.plotRect.height / props.yDomain.length;
      var _x = props.xScale(0);
      path2D.rect(_x, values.y - height / 2, values.x - _x, height - 2);
    }
    // fallback for the previous cases, bar with constant width
  } else {
    var _width = 10;
    if (props.barOrientation === 'horizontal') {
      var _x2 = props.xScale(0);
      path2D.rect(_x2, values.y - _width / 2, values.x - _x2, _width - 2);
    } else {
      var _y2 = props.yScale(0);
      path2D.rect(values.x - _width / 2, _y2, _width, values.y - _y2);
    }
  }
  return _extends({}, values, {
    path2D: path2D,
    type: 'area'
  });
};

var bars = exports.bars = function bars(props) {
  if (!props.xScale || !props.yScale) return undefined;
  return (0, _map3.default)((0, _flatten3.default)(props.data), function (datum, idx) {
    return getBarsRenderData(props, datum, idx);
  });
};