'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInitialState = exports.getName = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _isStatelessComponentFunction = require('../isStatelessComponentFunction');

var _isStatelessComponentFunction2 = _interopRequireDefault(_isStatelessComponentFunction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright 2017 Kensho Technologies, Inc.

function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}
var getName = exports.getName = function getName(name) {
  if (!name) return 'unknown';
  if (name[0] === '_') return name.substring(1);
  return name;
};
var getInitialState = exports.getInitialState = function getInitialState(initialState) {
  if (isFunction(initialState)) return initialState();
  return initialState;
};

/**
 * Funtion for wrapping 'stateless functional components' during development, allowing then to respond to onUpdate without changes to parent components.
 *
 * @example
 * import React, {PropTypes} from 'react'
 * import {Block} from '@luiscarli/display'
 * import Annotation from '../Annotation'
 *
 * export const handleAnnotationUpdate = (props, annotationProps) => {
 *   props.onUpdate({
 *     ...props,
 *     text: annotationProps.text,
 *   })
 * }
 *
 * const ExampleComponent = props => (
 *   <Block>
 *     <Annotation
 *       text={props.text}
 *       onUpdate={handleAnnotationUpdate.bind(null, props)}
 *     />
 *   </Block>
 * )
 *
 * ExampleComponent.propTypes = {
 *   onUpdate: PropTypes.func,
 *   text: PropTypes.string.isRequired,
 * }
 *
 * export default ExampleComponent
 */
var stateHOC = function stateHOC(Child) {
  var _class2, _temp4;

  var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if ((0, _isStatelessComponentFunction2.default)(Child)) {
    var _class, _temp2;

    return _temp2 = _class = function (_React$PureComponent) {
      _inherits(stateHOC, _React$PureComponent);

      function stateHOC() {
        var _ref;

        var _temp, _this, _ret;

        _classCallCheck(this, stateHOC);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = stateHOC.__proto__ || Object.getPrototypeOf(stateHOC)).call.apply(_ref, [this].concat(args))), _this), _this.state = _extends({}, getInitialState(Child.initialState), getInitialState(initialState)), _this.handleChildUpdate = function (childProps) {
          _this.setState(childProps);
        }, _temp), _possibleConstructorReturn(_this, _ret);
      }

      _createClass(stateHOC, [{
        key: 'render',
        value: function render() {
          return Child(_extends({}, this.props, this.state, {
            onUpdate: this.props.onUpdate || this.handleChildUpdate,
            onState: this.handleChildUpdate
          }));
        }
      }]);

      return stateHOC;
    }(_react2.default.PureComponent), _class.displayName = getName(Child.name) + '(state)', _class.defaultProps = Child.defaultProps, _temp2;
  }
  return _temp4 = _class2 = function (_React$PureComponent2) {
    _inherits(stateHOC, _React$PureComponent2);

    function stateHOC() {
      var _ref2;

      var _temp3, _this2, _ret2;

      _classCallCheck(this, stateHOC);

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _ret2 = (_temp3 = (_this2 = _possibleConstructorReturn(this, (_ref2 = stateHOC.__proto__ || Object.getPrototypeOf(stateHOC)).call.apply(_ref2, [this].concat(args))), _this2), _this2.state = _extends({}, getInitialState(Child.initialState), getInitialState(initialState)), _this2.handleChildUpdate = function (childProps) {
        _this2.setState(childProps);
      }, _temp3), _possibleConstructorReturn(_this2, _ret2);
    }

    _createClass(stateHOC, [{
      key: 'render',
      value: function render() {
        return _react2.default.createElement(Child, _extends({}, this.props, this.state, {
          onUpdate: this.props.onUpdate || this.handleChildUpdate
        }));
      }
    }]);

    return stateHOC;
  }(_react2.default.PureComponent), _class2.displayName = Child.displayName + '(state)', _class2.defaultProps = {}, _temp4;
};

exports.default = stateHOC;