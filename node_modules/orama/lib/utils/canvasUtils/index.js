'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canvasMock = exports.ctxMock = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // Copyright 2017 Kensho Technologies, Inc.

exports.getCachedContext = getCachedContext;
exports.clearRect = clearRect;
exports.fillRect = fillRect;
exports.strokeRect = strokeRect;

var _rectUtils = require('../rectUtils');

var noop = function noop() {
  return undefined;
};
var ctxMock = exports.ctxMock = {
  beginPath: noop,
  bezierCurveTo: noop,
  clearRect: noop,
  clip: noop,
  closePath: noop,
  fill: noop,
  fillRect: noop,
  fillText: noop,
  isPointInPath: noop,
  isPointInStroke: noop,
  lineTo: noop,
  measureText: function measureText(text) {
    return { width: text.toString().length };
  },
  arcTo: noop,
  moveTo: noop,
  quadraticCurveTo: noop,
  rect: noop,
  restore: noop,
  rotate: noop,
  save: noop,
  scale: noop,
  strokeRect: noop,
  strokeText: noop,
  transform: noop,
  translate: noop,
  stroke: noop,
  setLineDash: noop
};
var canvasMock = exports.canvasMock = {
  getContext: function getContext() {
    return ctxMock;
  },
  getBoundingClientRect: function getBoundingClientRect() {
    return { left: 0, top: 0, width: 500, height: 500 };
  }
};
var cachedCtx = void 0;
/*
Returns a cached offscreen canvas render.
In case the DOM is not available, returns a mocked render context.

The context returned by this function is shared, always call `save()` and `restore()` when manipulating it
*/
function getCachedContext() {
  if (cachedCtx) return cachedCtx;
  if (global.document && global.document.createElement) {
    cachedCtx = document.createElement('canvas').getContext('2d');
    return cachedCtx;
  }
  return ctxMock;
}

function clearRect(ctx, rectInput) {
  var rect = _extends({}, _rectUtils.rectBase, rectInput);
  ctx.clearRect(rect.x, rect.y, rect.width, rect.height);
}
function fillRect(ctx, rectInput) {
  var rect = _extends({}, _rectUtils.rectBase, rectInput);
  ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
}
function strokeRect(ctx, rectInput) {
  var rect = _extends({}, _rectUtils.rectBase, rectInput);
  ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
}