'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Brush = undefined;

var _includes2 = require('lodash/includes');

var _includes3 = _interopRequireDefault(_includes2);

var _max2 = require('lodash/max');

var _max3 = _interopRequireDefault(_max2);

var _min2 = require('lodash/min');

var _min3 = _interopRequireDefault(_min2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // Copyright 2017 Kensho Technologies, Inc.

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _stateHOC = require('../../utils/stateHOC');

var _stateHOC2 = _interopRequireDefault(_stateHOC);

var _Layer = require('../../Layer');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BRUSH_ELEMENT_NAMES = ['brushesCenter', 'brushesLeft', 'brushesRight', 'brushesTop', 'brushesBottom', 'brushesLeftTop', 'brushesRightTop', 'brushesRightBottom', 'brushesLeftBottom'];

var reorder = function reorder(bounds) {
  return {
    x1: (0, _min3.default)([bounds.x1, bounds.x2]),
    x2: (0, _max3.default)([bounds.x1, bounds.x2]),
    y1: (0, _min3.default)([bounds.y1, bounds.y2]),
    y2: (0, _max3.default)([bounds.y1, bounds.y2])
  };
};
var isOutOfBounds = function isOutOfBounds(bounds, plotRect) {
  if (bounds.x1 < plotRect.x || bounds.x2 > plotRect.x + plotRect.width || bounds.y1 < plotRect.y || bounds.y2 > plotRect.y + plotRect.height) return true;
  return false;
};
var constraintToPlotRect = function constraintToPlotRect(bounds, childProps) {
  var plotRect = childProps.rootProps.plotRect;

  var x1 = bounds.x1;
  if (x1 < plotRect.x) x1 = plotRect.x;
  var x2 = bounds.x2;
  if (x2 > plotRect.x + plotRect.width) x2 = plotRect.x + plotRect.width;
  var y1 = bounds.y1;
  if (y1 < plotRect.y) y1 = plotRect.y;
  var y2 = bounds.y2;
  if (y2 > plotRect.y + plotRect.height) y2 = plotRect.y + plotRect.height;
  return { x1: x1, x2: x2, y1: y1, y2: y2 };
};
var domainToBounds = function domainToBounds(props, childProps) {
  var rootProps = childProps.rootProps;

  return {
    x1: rootProps.xScale(props.xDomain[0]),
    x2: rootProps.xScale(props.xDomain[1]),
    y1: rootProps.yScale(props.yDomain[0]),
    y2: rootProps.yScale(props.yDomain[1])
  };
};
var boundsToDomain = function boundsToDomain(bounds, childProps) {
  var rootProps = childProps.rootProps;

  return {
    xDomain: [rootProps.xScale.invert(bounds.x1), rootProps.xScale.invert(bounds.x2)],
    yDomain: [rootProps.yScale.invert(bounds.y1), rootProps.yScale.invert(bounds.y2)]
  };
};
var getBrushData = function getBrushData(props) {
  return {
    x1: props.xDomain[0],
    x2: props.xDomain[1],
    y1: props.yDomain[0],
    y2: props.yDomain[1]
  };
};
var updateBounds = function updateBounds(props, childProps, partialBounds) {
  var newBounds = reorder(_extends({}, props._bounds, partialBounds));
  if (isOutOfBounds(newBounds, childProps.rootProps.plotRect)) {
    var constrainedBounds = constraintToPlotRect(newBounds, childProps);
    props.onUpdate(boundsToDomain(constrainedBounds, childProps));
  } else {
    props.onUpdate(boundsToDomain(newBounds, childProps));
  }
};

var mouseDown = function mouseDown(props, childProps) {
  var brushElementName = childProps.renderDatum && childProps.renderDatum.name;
  if (!(0, _includes3.default)(BRUSH_ELEMENT_NAMES, brushElementName)) {
    props.onState({
      _bounds: {
        x1: childProps.localMouse.x,
        y1: childProps.localMouse.y
      },
      brushElementName: brushElementName
    });
    props.onUpdate({ xDomain: undefined, yDomain: undefined });
  } else {
    props.onState({
      _bounds: domainToBounds(props, childProps),
      brushElementName: brushElementName
    });
  }
};
var mouseDrag = function mouseDrag(props, childProps) {
  if (props.brushElementName === 'brushesCenter') {
    var bounds = domainToBounds(props, childProps);
    var mBounds = {
      x1: bounds.x1 - childProps.mouseDelta.x,
      x2: bounds.x2 - childProps.mouseDelta.x,
      y1: bounds.y1 - childProps.mouseDelta.y,
      y2: bounds.y2 - childProps.mouseDelta.y
    };
    if (isOutOfBounds(mBounds, childProps.rootProps.plotRect)) {
      var constrainedBounds = constraintToPlotRect(bounds, childProps);
      props.onUpdate(boundsToDomain(constrainedBounds, childProps));
    } else {
      props.onUpdate(boundsToDomain(mBounds, childProps));
    }
  } else if (props.brushElementName === 'brushesLeft') {
    updateBounds(props, childProps, { x1: childProps.localMouse.x });
  } else if (props.brushElementName === 'brushesRight') {
    updateBounds(props, childProps, { x2: childProps.localMouse.x });
  } else if (props.brushElementName === 'brushesTop') {
    updateBounds(props, childProps, { y1: childProps.localMouse.y });
  } else if (props.brushElementName === 'brushesBottom') {
    updateBounds(props, childProps, { y2: childProps.localMouse.y });
  } else if (props.brushElementName === 'brushesLeftTop') {
    updateBounds(props, childProps, {
      x1: childProps.localMouse.x,
      y1: childProps.localMouse.y
    });
  } else if (props.brushElementName === 'brushesRightTop') {
    updateBounds(props, childProps, {
      x2: childProps.localMouse.x,
      y1: childProps.localMouse.y
    });
  } else if (props.brushElementName === 'brushesRightBottom') {
    updateBounds(props, childProps, {
      x2: childProps.localMouse.x,
      y2: childProps.localMouse.y
    });
  } else if (props.brushElementName === 'brushesLeftBottom') {
    updateBounds(props, childProps, {
      x1: childProps.localMouse.x,
      y2: childProps.localMouse.y
    });
  } else {
    var _bounds = reorder(_extends({}, props._bounds, {
      x2: childProps.localMouse.x,
      y2: childProps.localMouse.y
    }));
    var cBounds = constraintToPlotRect(_bounds, childProps);
    props.onUpdate(boundsToDomain(cBounds, childProps));
  }
  if (props.onMouseDown) props.onMouseDown();
};

var mouseUp = function mouseUp(props) {
  if (props.onMouseUp) props.onMouseUp();
};

var handleChart = function handleChart(props, childProps) {
  switch (childProps.action) {
    case 'mouseDown':
      mouseDown(props, childProps);
      break;
    case 'mouseDrag':
      mouseDrag(props, childProps);
      break;
    case 'mouseUp':
      mouseUp(props, childProps);
      break;
    default:
  }
};

var _Brush = function _Brush(props) {
  var child = _react2.default.Children.only(props.children);
  if (child.type.displayName === 'ChartWidthHOC') {
    var BrushElement = _react2.default.createElement(_Layer.Brushes, _extends({
      data: [getBrushData(props)],
      fillAlphaValue: props.fillAlphaValue,
      fillValue: props.fillValue,
      key: 'brushes',
      lineWidthValue: props.lineWidthValue,
      skipExtractArrays: true,
      strokeValue: props.strokeValue,
      tooltipShowKeys: false,
      x1: 'x1',
      x2: 'x2',
      y1: 'y1',
      y2: 'y2'
    }, props));
    var layers = _react2.default.Children.toArray(child.props.children).concat(BrushElement);
    return _react2.default.cloneElement(child, { onUpdate: function onUpdate(childProps) {
        return handleChart(props, childProps);
      } }, layers);
  }
  return _react2.default.createElement('div', null);
};

_Brush.propTypes = {
  children: _propTypes2.default.node,
  fillAlphaValue: _propTypes2.default.number,
  fillValue: _propTypes2.default.number,
  lineWidthValue: _propTypes2.default.number,
  strokeValue: _propTypes2.default.string,
  xDomain: _propTypes2.default.array,
  yDomain: _propTypes2.default.array
};
_Brush.defaultProps = {
  xDomain: [],
  yDomain: []
};

var Brush = exports.Brush = (0, _stateHOC2.default)(_Brush);